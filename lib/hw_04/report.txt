1. Почему принято решение расширить класс PostsController модулем, а не воспользоваться наследованием?

Ответ: по той причине, что в а) нашем случае у нас есть только один класс,
которому необходим дополнительный функционал, так что наследованием
пользоваться не совсем правильно и б) в случае, если бы Resource был классом,
а не модулем, наследование от него породило бы неверное иерархическое
отношение. Контроллер не является расширенной версией класса Resource.
Он является лишь классом, которому необходима функциональность Resource.

------------------------------------------------------------------

2. Как работает класс Router (в общем случае, а не только для PostController)?

    По шагам:
    1. При создании экземпляра класса Router создаётся хэш routes, куда в
    будущем будут помещаться экшены контроллера, с которым будет работать
    роутер.

    2. У экземпляра вызывается метод init, который в свою очередь вызывает
    инстанс-метод resources класса Router. Метод resources получается на вход
    класс-контроллер и строку, обозначающую, запросы к каким сущностям обрабатывает контроллер.

    3. Метод resources с помощью возможностей метапрограммирования в Ruby
    создаёт экземпляр полученного на вход класса и заполняет хэш routes данными
    типа request_method => { { action => controller_method } }, где request_method -
    метод HTTP-запроса, action - имя экшна, который будет выполнен в результате обработки запроса,
    controller_method - полученный опять же с помощью метапрограммирования метод
    контроллера, с которым работает метод. Если к методу запроса относится только
    один экшн, то в routes кладутся данные типа request_method => { controller_method }

    4. Далее начинается цикл, который запрашивает у юзера, с каким контроллером
    тот хочет взаимодействовать. Заканчивается цикл, если юзер введёт 'q'.

    5. Юзер выбрал нужный контроллер. Затем у выбранного контроллера вызывается
    метод класса connection, который тот получил из модуля Resource. Если путей,
    указывающих на экшены для контроллера, что ввёл пользователь нет, метод connection
    выводит сообщение об этом и закончит работу. В ином случае запросит метод HTTP-запроса, затем запросит
    экшн, относящийся к HTTP-запросу (если их больше одного). Далее вызывается 
    нужный экшн у выбранного контроллера. 
